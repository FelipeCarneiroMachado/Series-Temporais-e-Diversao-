---
title: "trabalho"
output: html_document
---

# Trabalho final de Séries Temporais e Aprendizado Dinâmico

Realizado por: - Felipe Carneiro Machado - Thales Sena de Queiroz - Felipe de Castro Azambuja

## Importação de pacotes

```{r}
library(tidyverse, quietly = TRUE)
library(ggplot2, quietly = TRUE)
library(broom, quietly = TRUE)
library(plotly, quietly = TRUE)
library(forecast, quietly = TRUE)
```


Serão analisadas séries temporais de criminalidade em São Paulo.

```{r}
taxa_delito_estado_sp <-  readxl::read_xlsx("../data/TaxaDelito-EstadoSP_20251020_211705.xlsx")
indicadores_seguranca_publica_uf <- readxl::read_excel("../data/indicadoressegurancapublicauf.xlsx")
```

O primeiro dataset contem o numero de ocorrencias anuais de certos tipos de crime apenas para SP. O segundo possui resolucao de meses para todos os estados brasileiros. Iremos fazer o recorte para o estado de SP.

```{r}
meses<- c('janeiro' = 1,'fevereiro' = 2,'março' = 3,'abril' = 4,'maio' =5,'junho' = 6 , 'julho'=7,'agosto'=8,'setembro'=9,'outubro'=10,'novembro'=11,'dezembro'=12)

crimes_mensal_sp_wide <- indicadores_seguranca_publica_uf |> 
  filter(UF == "São Paulo") |> 
  pivot_wider(
    names_from = c(`Tipo Crime`),
    values_from= Ocorrências
  ) |> 
  mutate(
    Mes_num = meses[str_trim(Mês)],
    Data = make_date(year = Ano, month = Mes_num)
  ) |> 
  select(
    !c(Ano, Mês, Mes_num, UF)
  ) |> 
  arrange(Data) |> 
  replace_na(list(`Lesão corporal seguida de morte` = 0))

crimes_mensal_sp_long <- crimes_mensal_sp_wide |> 
  pivot_longer(
    cols=!c(Data),
    names_to = "Tipo.crime",
    values_to = "Ocorrencia"
  )
```

Vamos plotar as series para visualizar as variacoes no tempo

```{r}
crimes_mensal_sp_wide |>
  pivot_longer(
    cols=!c(Data),
    names_to = "Tipo.crime",
    values_to = "Ocorrencia"
  ) |> 
  ggplot(aes(x = Data, y = Ocorrencia, color = `Tipo.crime`)) +
  geom_line()
```

Nota-se que furto e roubo de veiculos tem maiores valores, com sazonalidade mais aparente a primeira vista. Outros crimes tem valores mais constantes, sendo necessario visualizacao mais proxima

```{r}
crimes_mensal_sp_wide |>
  select(!c(`Roubo de veículo`, `Furto de veículo`)) |> 
  pivot_longer(
    cols=!c(Data),
    names_to = "Tipo.crime",
    values_to = "Ocorrencia"
  ) |> 
  ggplot(aes(x = Data, y = Ocorrencia, color = `Tipo.crime`)) +
  geom_line()
```


Observaremos primeiro a serie de Roubo de Veicuos

```{r}
crimes_mensal_sp_wide |> 
  filter(Data >= "2015-01-01" & Data <= "2020-01-01") |> 
  ggplot(aes(x = Data, y = `Roubo de veículo`))+
  geom_line() +
  scale_x_date(
    NULL,
    breaks = scales::breaks_width("6 month"),
    labels = scales::label_date("%y-%m")
  )
```


Aparenta-se que existe sazonalidade, observe picos proximos de outubro


## Analise geral de ACF e PACF

```{r}
roubos_ts <- crimes_mensal_sp_wide$`Roubo de veículo` |> 
  ts(start = c(2015, 1), end = c(2022, 8), frequency = 12)
acf(roubos_ts)
pacf(roubos_ts)
```


Nota-se que a ACF possui valores que decaindo, e a PACF possui poucos picos, sendo um na marca de um ano, indicando sazonalidade.


## Ajuste com modelo de Holt-Winters

```{r}
# Separacao de treino e teste 2015-2020 de treino, 2021-2022 de teste

train.roubos_ts <- window(roubos_ts, start = c(2015, 1), end = c(2020, 1))
test.roubos_ts <- window(roubos_ts, start = c(2020, 2))
hw.fit <- HoltWinters(train.roubos_ts, seasonal = "additive")
plot(hw.fit)
cat(sprintf("Holt-Winters ajustado\n"))
cat(sprintf("MSE = %f\n", hw.fit$SSE / length(train.roubos_ts)))
cat(sprintf("alpha = %f\n", hw.fit$alpha))
cat(sprintf("beta = %f\n", hw.fit$beta))
cat(sprintf("gama = %f\n", hw.fit$gamma))
```


```{r}
hw.forecast <- forecast(
  hw.fit,
  h = length(test.roubos_ts),
)
data.frame(
  time = c(time(window(train.roubos_ts, start = c(2016, 1))), time(test.roubos_ts)),
  original = c(as.numeric(window(train.roubos_ts, start = c(2016, 1))), as.numeric(test.roubos_ts)),
  predicted = c(as.numeric(hw.fit$fitted[,"xhat"]), as.numeric(hw.forecast$mean))
) |> 
  ggplot(aes(x = time)) +
  geom_vline(xintercept = 2020) +
  geom_line(aes(y = original, colour = "blue")) +
  geom_line(aes(y = predicted, colour = "orange"))
```

### Analise dos Residuos do Holt-Winters

Vamos plotar os residuos para ver se restou algum padrao. Se estiverem aleatorios (sem ondas), indica que o modelo esta bom.

```{r}
residuos <- residuals(hw.fit)

par(mfrow = c(1, 2))
plot(residuos, main = "Residuos ao longo do tempo", ylab = "Residuos")
abline(h = 0, col = "red", lty = 2)
hist(residuos, main = "Histograma dos Residuos", xlab = "Residuos", col = "lightblue", breaks = 15)
par(mfrow = c(1, 1))
```

Se os residuos parecerem aleatorios, o modelo capturou bem os padroes da serie.


### Metricas de Erro do Holt-Winters

Agora vamos calcular as metricas de erro para avaliar as previsoes.

```{r}
acc <- accuracy(hw.forecast, test.roubos_ts)

cat("\n=== Metricas de Desempenho ===\n")
cat(sprintf("RMSE (Test): %.2f\n", acc[2, "RMSE"]))
cat(sprintf("MAPE (Test): %.2f%%\n", acc[2, "MAPE"]))
```

O MAPE mostra o percentual de erro medio. O RMSE mostra o erro em numero de roubos.


## Ajuste com modelo SARIMA

Agora vamos ajustar um modelo SARIMA para comparar com o Holt-Winters. Usaremos a funcao auto.arima() para encontrar o melhor modelo automaticamente.

```{r}
sarima.fit <- auto.arima(train.roubos_ts, seasonal = TRUE, stepwise = FALSE, approximation = FALSE)
summary(sarima.fit)
```

Realizamos a previsao para o periodo de teste:

```{r}
sarima.forecast <- forecast(sarima.fit, h = length(test.roubos_ts))

data.frame(
  time = c(time(window(train.roubos_ts, start = c(2016, 1))), time(test.roubos_ts)),
  original = c(as.numeric(window(train.roubos_ts, start = c(2016, 1))), as.numeric(test.roubos_ts)),
  predicted = c(as.numeric(window(fitted(sarima.fit), start = c(2016, 1))), as.numeric(sarima.forecast$mean))
) |> 
  ggplot(aes(x = time)) +
  geom_vline(xintercept = 2020) +
  geom_line(aes(y = original, colour = "blue")) +
  geom_line(aes(y = predicted, colour = "orange"))
```


### Analise dos Residuos do SARIMA

Verificamos se os residuos do SARIMA se comportam de forma aleatoria.

```{r}
residuos_sarima <- residuals(sarima.fit)

par(mfrow = c(1, 2))
plot(residuos_sarima, main = "Residuos ao longo do tempo", ylab = "Residuos")
abline(h = 0, col = "red", lty = 2)
hist(residuos_sarima, main = "Histograma dos Residuos", xlab = "Residuos", col = "lightblue", breaks = 15)
par(mfrow = c(1, 1))
```


### Metricas de Erro do SARIMA

Calculamos as metricas de erro para comparar com o Holt-Winters.

```{r}
acc_sarima <- accuracy(sarima.forecast, test.roubos_ts)

cat("\n=== Metricas de Desempenho (SARIMA) ===\n")
cat(sprintf("RMSE (Test): %.2f\n", acc_sarima[2, "RMSE"]))
cat(sprintf("MAPE (Test): %.2f%%\n", acc_sarima[2, "MAPE"]))
```